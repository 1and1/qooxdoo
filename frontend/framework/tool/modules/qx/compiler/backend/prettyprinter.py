#!/usr/bin/env python

################################################################################
#  qooxdoo - the new era of web development
#
#  http://qooxdoo.org
#
#  Copyright:
#    2006-2007 1&1 Internet AG, Germany, http://www.1and1.org
#
#  License:
#    LGPL: http://www.gnu.org/licenses/lgpl.html
#    EPL: http://www.eclipse.org/org/documents/epl-v10.php
#    See the LICENSE file in the project's top-level directory for details.
#
#  Authors:
#    * Sebastian Werner (wpbasti)
#    * Alessandro Sala (asala)
#    * Thomas Herchenroeder (thron7)
################################################################################

##
#<h2>Module Description</h2>
#<pre>
#
# NAME
#  prettyprinter.py -- produce nicely formatted JavaScript
#
# SYNTAX
#  from qx.compiler.backend.prettyprinter import *
#  retcode = output(qx_ast)
#
#  qx_ast -- root node of an abstract syntax tree (qx.compiler.ast)
#
#</pre>
##

##
# Generate nicely formatted JavaScript from qooxdoo AST.
#
# @param ast qooxdoo Abstract Syntax Tree (as generated by the frontend)

def output(ast):
    pass


import sys, os, string, re, optparse
sys.path.insert(0, os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), "../../../"))

import config, tokenizer, filetool, treegenerator, variableoptimizer, comment, tree

_KEY = re.compile("^[A-Za-z0-9_$]+$")
result = u''


def compileToken(name, compact=False):
    global pretty
    r=""


    if name in ["INC", "DEC", "TYPEOF"]:
        pass

    elif name in ["INSTANCEOF", "IN"]:
        r+=space()

    elif not compact and pretty:
        r+=space()



    if name == None:
        write("=")
        r+="="

    elif name in ["TYPEOF", "INSTANCEOF", "IN"]:
        write(name.lower())
        r+=name.lower()

    else:
        for key in config.JSTOKENS:
            if config.JSTOKENS[key] == name:
                write(key)
                r+=key



    if name in ["INC", "DEC"]:
        pass

    elif name in ["TYPEOF", "INSTANCEOF", "IN"]:
        r+=space()

    elif not compact and pretty:
        r+=space()

    return r


def space(force=True):
    global indent
    global result
    global pretty
    global afterLine
    global afterBreak
    global afterDoc

    if not force and not pretty:
        return ""

    if afterDoc or afterBreak or afterLine or result.endswith(" ") or result.endswith("\n"):
        return ""

    result += " "
    return " "


def write(txt=""):
    global indent
    global result
    global pretty
    global breaks
    global afterLine
    global afterBreak
    global afterDoc
    global afterDivider
    global afterArea

    # strip remaining whitespaces
    if (afterLine or afterBreak or afterDivider or afterArea) and result.endswith(" "):
        result = result.rstrip()

    if pretty:
        # handle new line wishes
        if afterArea:
            nr = 5
        elif afterDivider:
            nr = 5
        elif afterDoc:
            nr = 3
        elif afterBreak:
            nr = 2
        elif afterLine:
            nr = 1
        else:
            nr = 0

        while not result.endswith("\n" * nr):
            result += "\n"

    elif breaks and not result.endswith("\n"):
        if afterArea or afterDivider or afterDoc or afterBreak or afterLine:
            result += "\n"

    # reset
    afterLine = False
    afterBreak = False
    afterDoc = False
    afterDivider = False
    afterArea = False

    # add indent (if needed)
    if pretty and result.endswith("\n"):
        #result += (" " * (INDENTSPACES * indent))
        result += (options.prettypIndentString * indent)

    # append given text
    result += txt


def area():
    global afterArea
    afterArea = True


def divide():
    global afterDivider
    afterDivider = True


def sep():
    global afterBreak
    afterBreak = True


def doc():
    global afterDoc
    afterDoc = True


def nosep():
    global afterBreak
    afterBreak = False


def line():
    global afterLine
    afterLine = True


def noline():
    global afterLine
    global afterBreak
    global afterDivider
    global afterArea
    global afterDoc

    afterLine = False
    afterBreak = False
    afterDivider = False
    afterArea = False
    afterDoc = False


def plus():
    global indent
    indent += 1


def minus():
    global indent
    indent -= 1


def semicolon():
    global result
    global breaks

    noline()

    if not (result.endswith("\n") or result.endswith(";")):
        write(";")
        return ";"

        if breaks:
            result += "\n"


def commentNode(node):
    global pretty

    if not pretty:
        return

    commentText = ""
    commentIsInline = False

    comment = node.getChild("commentsAfter", False)

    if comment and not comment.get("inserted", False):
        for child in comment.children:
            if not child.isFirstChild():
                commentText += " "

            commentText += child.get("text")

            if child.get("detail") == "inline":
                commentIsInline = True

        if commentText != "":
            if options.prettypCommentsInlinePadding:
                commentText.strip()
                commentText = options.prettypCommentsInlinePadding + commentText
            else:
                space()
            ##space()
            write(commentText)

            if commentIsInline:
                line()
            else:
                space()

            comment.set("inserted", True)



def postProcessMap(m):
    if m.get("maxKeyLength", False) != None:
        return

    maxKeyLength = 0
    alignValues = True

    if m.hasChildren():
        for keyvalue in m.children:
            if keyvalue.type != "keyvalue":
                continue

            currKeyLength = len(keyvalue.get("key"))

            if keyvalue.get("quote", False) != None:
                currKeyLength += 2

            if currKeyLength > maxKeyLength:
                maxKeyLength = currKeyLength

            if alignValues and keyvalue.getChild("value").isComplex():
                alignValues = False

    m.set("maxKeyLength", maxKeyLength)
    m.set("alignValues", alignValues)




def inForLoop(node):
    while node:
        if node.type in ["first", "second", "third"] and node.parent.type == "loop" and node.parent.get("loopType") == "FOR":
            return True

        if not node.hasParent():
            return False

        node = node.parent

    return False




def compile(node, opts, enableBreaks=False, verbose=False):
    global indent
    #global result
    global pretty
    global verbose
    global breaks
    global afterLine
    global afterBreak
    global afterDoc
    global afterDivider
    global afterArea
    global options

    options = opts
    options.prettypIndentString = eval("'" + options.prettypIndentString + "'")
                                                              # allow for escapes like "\t"

    indent       = 0
    result       = u""
    pretty       = opts.prettyPrint
    verbose      = verbose
    breaks       = enableBreaks
    afterLine    = False
    afterBreak   = False
    afterDoc     = False
    afterDivider = False
    afterArea    = False

    if pretty:
        comment.fill(node)

    result = compileNode(node,opts)

    if not result.endswith("\n"):
        result += "\n"

    return result








def compileNode(node,optns,context={}):

    global pretty
    global indent




    #####################################################################################################################
    # Recover styling
    #####################################################################################################################

    if pretty:
        # Recover exclicit breaks
        if node.get("breakBefore", False) and not node.isFirstChild(True):
            sep()

        # Additional explicit break before complex blocks
        if node.hasParent() and not node.isFirstChild(True) and node.parent.type in ["block", "file"] and node.isComplex():
            sep()



    #####################################################################################################################
    # Insert comments before
    #####################################################################################################################

    if pretty:
        if node.getChild("commentsBefore", False) != None:
            commentCounter = 0
            commentsBefore = node.getChild("commentsBefore")
            isFirst = node.isFirstChild()
            previous = node.getPreviousSibling(False, True)

            if previous and previous.type in ["case", "default"]:
                inCase = True
            else:
                inCase = False

            inOperation = node.parent.type in ["first", "second", "third"] and node.parent.parent.type == "operation"

            for child in commentsBefore.children:
                docComment = child.get("detail") in ["javadoc", "qtdoc"]
                headComment = child.get("detail") == "header"
                areaComment = child.get("detail") == "area"
                divComment = child.get("detail") == "divider"
                blockComment = child.get("detail") ==  "block"
                singleLineBlock = child.get("detail") != "inline" and child.get("multiline") == False

                if not child.isFirstChild():
                    pass

                elif inCase:
                    pass

                elif singleLineBlock:
                    if child.get("begin"):
                        sep()
                    else:
                        space()

                elif areaComment and not isFirst:
                    area()

                elif divComment and not isFirst:
                    divide()

                elif not isFirst:
                    if docComment:
                        doc()
                    else:
                        sep()

                elif inOperation:
                    sep()

                elif not headComment:
                    line()

                # reindenting first
                text = child.get("text")

                if child.get("detail") == "qtdoc":
                    text = comment.qt2javadoc(text)

                #write(comment.indent(text, INDENTSPACES * indent))
                write(comment.indent(text, optns.prettypIndentString * indent))

                if singleLineBlock:
                    if docComment:
                        line()
                    elif child.get("end"):
                        sep()
                    else:
                        space()

                # separator after divider/head comments and after block comments which are not for documentation
                elif headComment or areaComment or divComment or blockComment:
                    sep()

                else:
                    line()

    #####################################################################################################################
    # Children content
    #####################################################################################################################

    context = {}

    try:
        (pre,post) = (dispatch[node.type])(node,optns,context)
    except KeyError:
        (pre,post) = OTHER(node,optns,context)

    childBlock = ""

    if node.hasChildren() and (not node.type in ["commentsBefore", "commentsAfter"]):
        for child in node.children:
            childBlock += compileNode(child,optns,context)

    childBlock = indentBlock(childBlock)

    result = pre + childBlock + post

    return result


def indentBlock(block):
    """Goes through block and indents lines properly
    """

    return block


#####################################################################################################################
# Opening...
#####################################################################################################################

    #
def FINALLY(node,optns,context):
    ##################################

    if node.type == "finally":
        return ("finally","")


    #
def DELETE(node,optns,context):
    ##################################

    if node.type == "delete":
        return ("delete %s" % space(), "")
        #space()


    #
def THROW(node,optns,context):
    ##################################

    if node.type == "throw":
        #write("throw")
        #space()
        return ("throw","")


    #
def NEW(node,optns,context):
    ##################################

    if node.type == "instantiation":
        #write("new")
        #space()
        return ("new", "")


    #
def RETURN(node,optns,context):
    ##################################

    if node.type == "return":
        #write("return")

        if node.hasChildren():
            s=space()
        return ("return","")


    #
def DEFINITIONLIST(node,optns,context):
    ##################################

    if node.type == "definitionList":
        #write("var")
        #space()
        return ("var","")


    #
def BREAK(node,optns,context):
    ##################################

    if node.type == "break":
        write("break")

        s=""
        if node.get("label", False):
            #space()
            #write(node.get("label", False))
            s=space() + node.get("label", False)

        return ("break" % s, "")


    #
def CONTINUE(node,optns,context):
    ##################################

    if node.type == "continue":
        write("continue")

        s=""
        if node.get("label", False):
            #space()
            #write(node.get("label", False))
            s=space() + node.get("label", False)

        return ("continue" % s, "")

    #
def FUNCTION(node,optns,context):
    ##################################

    if node.type == "function":
        write("function")

        pre="function"
        functionName = node.get("name", False)
        if functionName != None:
            space()
            write(functionName)
            pre+=space() + functionName

    # CLOSE: FUNCTION
    ##################################

        post=""
        if pretty:
            commentNode(node)

            if not node.isLastChild() and node.hasParent() and node.parent.type in ["block", "file"]:
                sep()

        return (pre,post)


    #
def IDENTIFIER(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "identifier":
        name = node.get("name", False)
        if name != None:
            write(name)
            pre=name
    #
    # CLOSE: IDENTIFIER
    ##################################

        if node.hasParent() and node.parent.type == "variable" and not node.isLastChild(True):
            write(".")
            post="."
        elif node.hasParent() and node.parent.type == "label":
            write(":")
            post=":"

        return (pre,post)



    #
def DEFINITION(node,optns,context):
    ##################################

    if node.type == "definition":
        if node.parent.type != "definitionList":
            write("var")
            space()
            pre="var" + space()

        write(node.get("identifier"))
        pre+=node.get("identifier")
    #
    # CLOSE: DEFINITION
    ##################################

        post=""
        if node.hasParent() and node.parent.type == "definitionList" and not node.isLastChild(True):
            write(",")
            post+=","

            if pretty:
                commentNode(node)

                if node.hasComplexChildren():
                    line()
                else:
                    space()

        return (pre,post)



    #
def CONSTANT(node,optns,context):
    ##################################

    pre=""
    if node.type == "constant":
        if node.get("constantType") == "string":
            if node.get("detail") == "singlequotes":
                write("'")
                pre+="'"
            else:
                write('"')
                pre+='"'

            write(node.get("value"))
            pre+=node.get("value")

            if node.get("detail") == "singlequotes":
                write("'")
                pre+="'"
            else:
                write('"')
                pre+='"'

        else:
            write(node.get("value"))
            pre+=node.get("value")

        return (pre,"")

    #
def COMMENT(node,optns,context):
    ##################################

    pre=""
    if node.type == "comment":
        if pretty:
            commentText = node.get("text")
            # insert a space before and no newline in the case of after comments
            if node.get("connection") == "after":
                noline()
                if optns.prettypCommentsInlinePadding:
                    commentText.strip()
                    commentText = optns.prettypCommentsInlinePadding + commentText
                else:
                    space()
                ##space()

            ##write(node.get("text"))
            write(commentText)
            pre+=commentText

            # new line after inline comment (for example for syntactical reasons)
            #if (node.get("detail") == "inline") or (node.get("multiline") == False):
            if (node.get("detail") == "inline") or (node.get("end") == True):
                line()
            else:
                space()

        return (pre,"")

    #
def RIGHT(node,optns,context):
    ##################################

    pre=""
    if node.type == "right":
        if node.parent.type == "accessor":
            write(".")
            pre+="."

        return (pre,"")





    #
def ASSIGNMENT(node,optns,context):
    ##################################

    pre=""
    if node.type == "assignment":
        if node.parent.type == "definition":
            oper = node.get("operator", False)

            # be compact in for-loops
            compact = inForLoop(node)
            pre+=compileToken(oper, compact)

        return (pre,"")




    #
def KEY(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "key":
        if node.parent.type == "accessor":
            write("[")
            pre+="["
    ##################################

        if node.hasParent() and node.parent.type == "accessor":
            write("]")
            post+="]"

        return (pre,post)

    #
def GROUP(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "group":
        write("(")
        pre+="("
    #
    # CLOSE: GROUP
    ##################################

        if node.getChildrenLength(True) == 1:
            noline()

        write(")")
        post+=")"

        return (pre,post)



    #
def VOID(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "void":
        write("void")
        write("(")
        pre+="void("
    #
    # CLOSE: VOID
    ##################################

        if node.getChildrenLength(True) == 1:
            noline()

        write(")")
        post+=")"

        return (pre,post)



    #
def ARRAY(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "array":
        write("[")
        pre+="["

        if node.hasChildren(True):
            space(False)
    #
    # CLOSE: ARRAY
    ##################################

        if node.hasChildren(True):
            space(False)

        write("]")
        post+="]"



    #
def PARAMS(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "params":
        noline()
        write("(")
        pre+="("
    #
    # CLOSE: PARAMS
    ##################################

        write(")")
        post+=")"

        return (pre,post)


    #
def CASE(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "case":
        if pretty:
            # force double new lines
            if not node.isFirstChild() and not node.getPreviousSibling(True).type == "case":
                sep()

            minus()
            line()

        write("case")
        space()
        pre+="case "
    #
    # CLOSE: CASE
    ##################################

        write(":")
        post+=":"

        if pretty:
            commentNode(node)
            plus()
            line()

        return (pre,post)


    #
def DEFAULT(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "default":
        if pretty:
            minus()

            # force double new lines
            if not node.getPreviousSibling(True).type == "case":
                sep()

        write("default")
        write(":")
        pre+="default :"

        if pretty:
            plus()
            line()

        return (pre,post)

    #
def TRY(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "switch":
        # Additional new line before each switch/try
        if not node.isFirstChild(True) and not node.getChild("commentsBefore", False):
            prev = node.getPreviousSibling(False, True)

            # No separation after case statements
            if prev != None and prev.type in ["case", "default"]:
                pass
            else:
                sep()

        if node.get("switchType") == "catch":
            write("try")
            pre+="try"
        elif node.get("switchType") == "case":
            write("switch")
            pre+="switch"

        return (pre,post)

    #
def CATCH(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "catch":
        if pretty:
            # If this statement block or the previous try were not complex, be not complex here, too
            if not node.getChild("statement").getChild("block").isComplex() and not node.parent.getChild("statement").getChild("block").isComplex():
                noline()
                space()

        write("catch")
        pre+="catch"

        return (pre,post)


    #
def MAP(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "map":
        par = node.parent

        if pretty:
            postProcessMap(node)

        if pretty:
            # No break before return statement
            if node.hasParent() and node.parent.type == "expression" and node.parent.parent.type == "return":
                pass

            elif node.isComplex() or optns.prettypOpenCurlyNewlineBefore:
                line()

            if optns.prettypOpenCurlyIndentBefore:
                plus()

        write("{")
        pre+="{"

        if pretty:
            if node.isComplex():
                line()
                plus()

            elif node.hasChildren(True):
                space()
    #
    # CLOSE: MAP
    ##################################

        if pretty:
            if node.isComplex():
                line()
                minus()

            elif node.hasChildren(True):
                space()

        write("}")
        post+="}"

        if pretty:
                if optns.prettypOpenCurlyIndentBefore:
                    minus()

        return (pre,post)





    #
def KEYVALUE(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "keyvalue":
        keyString = node.get("key")
        keyQuote = node.get("quote", False)

        if keyQuote != None:
            # print "USE QUOTATION"
            if keyQuote == "doublequotes":
                keyString = '"' + keyString + '"'
            else:
                keyString = "'" + keyString + "'"

        elif keyString in config.JSPROTECTED or not _KEY.match(keyString):
            print "Warning: Auto protect key: %s" % keyString
            keyString = "\"" + keyString + "\""

        if pretty and not node.isFirstChild(True) and not node.hasChild("commentsBefore") and node.getChild("value").isComplex():
            sep()

        write(keyString)
        pre+=keyString
        space(False)

        # Fill with spaces
        # Do this only if the parent is complex (many entries)
        # But not if the value itself is complex
        if pretty and node.parent.isComplex() and node.parent.get("alignValues"):
            write(" " * (node.parent.get("maxKeyLength") - len(keyString)))
            pre+=(" " * (node.parent.get("maxKeyLength") - len(keyString)))

        write(":")
        pre+=":"
        space(False)
    #
    # CLOSE: KEYVALUE
    ##################################

        if node.hasParent() and node.parent.type == "map" and not node.isLastChild(True):
            noline()
            write(",")
            post+=","

            if pretty:
                commentNode(node)

                if node.getChild("value").isComplex():
                    sep()
                elif node.parent.isComplex():
                    line()
                else:
                    space()

        return (pre,post)


    #
def BLOCK(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "block":
        if pretty:
            if node.isComplex() or optns.prettypOpenCurlyNewlineBefore:
                line()
            else:
                space()

            if optns.prettypOpenCurlyIndentBefore:
                plus()

        write("{")
        pre+="{"

        if pretty:
            if node.hasChildren():
                plus()
                line()
    #
    # CLOSE: BLOCK
    ##################################

        if pretty and node.hasChildren():
            minus()
            line()

        write("}")
        post+="}"

        if pretty:
            commentNode(node)

            if node.hasChildren():
                # Newline afterwards
                if node.parent.type == "body" and node.parent.parent.type == "function":

                    # But only when this isn't a function block inside a assignment
                    if node.parent.parent.parent.type in ["right", "params"]:
                        pass

                    elif node.parent.parent.parent.type == "value" and node.parent.parent.parent.parent.type == "keyvalue":
                        pass

                    else:
                        line()

                else:
                    line()

            if optns.prettypOpenCurlyIndentBefore:
                minus()

        return (pre,post)



    #
def LOOP(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "loop":
        # Additional new line before each loop
        if not node.isFirstChild(True) and not node.getChild("commentsBefore", False):
            prev = node.getPreviousSibling(False, True)

            # No separation after case statements
            if prev != None and prev.type in ["case", "default"]:
                pass
            elif node.hasChild("elseStatement") or node.getChild("statement").hasBlockChildren():
                sep()
            else:
                line()

        loopType = node.get("loopType")

        if loopType == "IF":
            write("if")
            pre+="if"
            space(False)

        elif loopType == "WHILE":
            write("while")
            pre+="while"
            space(False)

        elif loopType == "FOR":
            write("for")
            pre+="for"
            space(False)

        elif loopType == "DO":
            write("do")
            pre+="do"
            space(False)

        elif loopType == "WITH":
            write("with")
            pre+="with"
            space(False)

        else:
            print "Warning: Unknown loop type: %s" % loopType
    #
    # CLOSE: LOOP
    ##################################

        if node.get("loopType") == "DO":
            post+=semicolon()

        if pretty:
            commentNode(node)

            # Force a additinal line feed after each loop
            if not node.isLastChild():
                if node.hasChild("elseStatement"):
                    sep()
                elif node.getChild("statement").hasBlockChildren():
                    sep()
                else:
                    line()

        return (pre,post)


    #
def ELSE(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "elseStatement":
        if node.hasChild("commentsBefore"):
            pass

        elif pretty:
            if not node.hasChild("block") and not node.hasChild("loop"):
                pass

            elif not node.isComplex():
                noline()
                space()

        write("else")
        pre+="else"

        # This is a elseStatement without a block around (a set of {})
        if not node.hasChild("block"):
            space()

        return (pre,post)


    #
def EXPRESSION(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "expression":
        if node.parent.type == "loop":
            loopType = node.parent.get("loopType")

            # only do-while loops
            if loopType == "DO":
                if pretty:
                    stmnt = node.parent.getChild("statement")
                    compact = stmnt.hasChild("block") and not stmnt.getChild("block").isComplex()

                    if compact:
                        noline()
                        space()

                write("while")
                pre+="while"

                if pretty:
                    space()

            # open expression block of IF/WHILE/DO-WHILE/FOR statements
            write("(")
            pre+="("

        elif node.parent.type == "catch":
            # open expression block of CATCH statement
            write("(")
            pre+="("

        elif node.parent.type == "switch" and node.parent.get("switchType") == "case":
            # open expression block of SWITCH statement
            write("(")
            pre+="("
    #
    # CLOSE: EXPRESSION
    ##################################

        if node.parent.type == "loop":
            write(")")
            post+=")"

            # e.g. a if-construct without a block {}
            if node.parent.getChild("statement").hasChild("block"):
                pass

            elif node.parent.getChild("statement").hasChild("emptyStatement"):
                pass

            elif node.parent.type == "loop" and node.parent.get("loopType") == "DO":
                pass

            else:
                space(False)

        elif node.parent.type == "catch":
            write(")")
            post+=")"

        elif node.parent.type == "switch" and node.parent.get("switchType") == "case":
            write(")")
            post+=")"

            if pretty:
                commentNode(node)
                line()
                if optns.prettypOpenCurlyIndentBefore:
                    plus()


            write("{")
            post+="{"

            if pretty:
                plus()
                plus()


        return (pre,post)



    #
def FIRST(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "first":
        # for loop
        if node.parent.type == "loop" and node.parent.get("loopType") == "FOR":
            write("(")
            pre+="("

        # operation
        elif node.parent.type == "operation":
            # operation (var a = -1)
            if node.parent.get("left", False) == True:
                pre+=compileToken(node.parent.get("operator"), True)
    #
    # CLOSE: FIRST
    ##################################

        # for loop
        if node.parent.type == "loop" and node.parent.get("loopType") == "FOR":
            if node.parent.get("forVariant") == "iter":
                write(";")
                post+=";"

                if node.parent.hasChild("second"):
                    space(False)

        # operation
        elif node.parent.type == "operation" and node.parent.get("left", False) != True:
            oper = node.parent.get("operator")

            # be compact in for loops
            compact = inForLoop(node)
            post+=compileToken(oper, compact)

        return (pre,post)


    #
def SECOND(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "second":
        # for loop
        if node.parent.type == "loop" and node.parent.get("loopType") == "FOR":
            if not node.parent.hasChild("first"):
                write("(;")
                pre+="(;"

        # operation
        elif node.parent.type == "operation":
            if node.isComplex():
                # (?: hook operation)
                if node.parent.get("operator") == "HOOK":
                    sep()
                else:
                    line()
    #
    # CLOSE: SECOND
    ##################################

        # for loop
        if node.parent.type == "loop" and node.parent.get("loopType") == "FOR":
            write(";")
            post+=";"

            if node.parent.hasChild("third"):
                space(False)

        # operation
        elif node.parent.type == "operation":
            # (?: hook operation)
            if node.parent.get("operator") == "HOOK":
                noline()
                space(False)
                write(":")
                post+=":"
                space(False)

        return (pre,post)


    #
def THIRD(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "third":
        # for loop
        if node.parent.type == "loop" and node.parent.get("loopType") == "FOR":
            if not node.parent.hasChild("second"):
                if node.parent.hasChild("first"):
                    write(";")
                    pre+=";"
                    space(False)
                else:
                    write("(;;")
                    pre+="(;;"

        # operation
        elif node.parent.type == "operation":
            # (?: hook operation)
            if node.parent.get("operator") == "HOOK":
                if node.isComplex():
                    sep()

        return (pre,post)


    #
def STATEMENT(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "statement":
        # for loop
        if node.parent.type == "loop" and node.parent.get("loopType") == "FOR":
            if node.parent.get("forVariant") == "iter":
                if not node.parent.hasChild("first") and not node.parent.hasChild("second") and not node.parent.hasChild("third"):
                    write("(;;");
                    pre+="(;;"

                elif not node.parent.hasChild("second") and not node.parent.hasChild("third"):
                    write(";")
                    pre+=";"

            write(")")
            pre+=")"

            if not node.hasChild("block"):
                space(False)

        return (pre,post)


    #####################################################################################################################
    # Closing node
    #####################################################################################################################

    #
def ACCESSOR(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "accessor":
        if node.hasParent() and node.parent.type == "variable" and not node.isLastChild(True):
            write(".")
            post+="."

        return (pre,post)


    #
def LEFT(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "left":
        if node.hasParent() and node.parent.type == "assignment":
            oper = node.parent.get("operator", False)

            # be compact in for-loops
            compact = inForLoop(node)
            post+=compileToken(oper, compact)

        return (pre,post)


    #
def SWITCH(node,optns,context):
    ##################################

    pre=post=""
    if node.type == "switch":
        if node.get("switchType") == "case":
            if pretty:
                minus()
                minus()
                line()

            write("}")
            post+="}"

            if pretty:
                commentNode(node)
                line()
                if optns.prettypOpenCurlyIndentBefore:
                    minus()

        # Force a additinal line feed after each switch/try
        if pretty and not node.isLastChild():
            sep()

        return (pre,post)


    #
def OTHER(node,optns,context):
    ##################################

    pre=post=""
    if node.hasParent() and not node.type in ["comment", "commentsBefore", "commentsAfter"]:

        # Add comma dividers between statements in these parents
        if node.parent.type in ["array", "params", "statementList"]:
            if not node.isLastChild(True):
                write(",")
                pre+=","

                if pretty:
                    commentNode(node)

                    if node.isComplex():
                        line()
                    else:
                        space()

        # Semicolon handling
        elif node.type in ["group", "block", "assignment", "call", "operation", "definitionList", "return", "break", "continue", "delete", "accessor", "instantiation", "throw", "variable", "emptyStatement"]:

            # Default semicolon handling
            if node.parent.type in ["block", "file"]:
                pre+=semicolon()

                if pretty:
                    commentNode(node)
                    line()

                    if node.isComplex() and not node.isLastChild():
                        sep()

            # Special handling for switch statements
            elif node.parent.type == "statement" and node.parent.parent.type == "switch" and node.parent.parent.get("switchType") == "case":
                pre+=semicolon()

                if pretty:
                    commentNode(node)
                    line()

                    if node.isComplex() and not node.isLastChild():
                        sep()

            # Special handling for loops (e.g. if) without blocks {}
            elif (
                node.parent.type in ["statement", "elseStatement"] and
                not node.parent.hasChild("block") and
                node.parent.parent.type == "loop"
            ):
                pre+=semicolon()

                if pretty:
                    commentNode(node)
                    line()

                    if node.isComplex() and not node.isLastChild():
                        sep()



    #
    # CLOSE: OTHER
    ##################################

    if pretty:
        # Rest of the after comments (not inserted previously)
        commentNode(node)

    return (pre,post)


# for compileNode()
dispatch = {
        'accessor'    : ACCESSOR,
        'array'       : ARRAY,
        'assignment'  : ASSIGNMENT,
        'block'       : BLOCK,
        'break'       : BREAK,
        'case'        : CASE,
        'catch'       : CATCH,
        'comment'     : COMMENT,
        'constant'    : CONSTANT,
        'continue'    : CONTINUE,
        'default'     : DEFAULT,
        'definition'  : DEFINITION,
        'definitionList'  : DEFINITIONLIST,
        'delete'      : DELETE,
        'elseStatement'        : ELSE,
        'expression'  : EXPRESSION,
        'finally'     : FINALLY,
        'first'       : FIRST,
        'function'    : FUNCTION,
        'group'       : GROUP,
        'identifier'  : IDENTIFIER,
        'instantiation'         : NEW,
        'key'         : KEY,
        'keyvalue'    : KEYVALUE,
        'left'        : LEFT,
        'loop'        : LOOP,
        'map'         : MAP,
        'OTHER'       : OTHER,
        'params'      : PARAMS,
        'return'      : RETURN,
        'right'       : RIGHT,
        'second'      : SECOND,
        'statement'   : STATEMENT,
        'switch'      : SWITCH,
        'switch'         : TRY,
        'third'       : THIRD,
        'throw'       : THROW,
        'void'        : VOID,
    }





def main():
    global options

    parser = optparse.OptionParser()

    parser.add_option("-w", "--write", action="store_true", dest="write", default=False, help="Writes file to incoming fileName + EXTENSION.")
    parser.add_option("-e", "--extension", dest="extension", metavar="EXTENSION", help="The EXTENSION to use", default="")
    parser.add_option("-c", "--compress", action="store_true", dest="compress", help="Enable compression", default=False)
    parser.add_option("--optimize-variables", action="store_true", dest="optimizeVariables", default=False, help="Optimize variables. Reducing size.")
    parser.add_option("--encoding", dest="encoding", default="utf-8", metavar="ENCODING", help="Defines the encoding expected for input files.")
    # Options for pretty printing
    parser.add_option("--pretty-print-indent-string", dest="prettypIndentString", default="  ", help="String used for indenting source code; escapes possible (e.g. \"\\t\"; default: \"  \")")
    parser.add_option("--pretty-print-newline-before-open-curly", action="store_true", dest="prettypOpenCurlyNewlineBefore", default=False, help="Force \"{\" to be on a new line (default: False)")
    parser.add_option("--pretty-print-indent-before-open-curly", action="store_true", dest="prettypOpenCurlyIndentBefore", default=False, help="Indent \"{\" (default: False)")
    parser.add_option("--pretty-print-inline-comment-padding", dest="prettypCommentsInlinePadding", default="  ", help="String used between the end of a statement and a trailing inline comment (default: \"  \")")


    (options, args) = parser.parse_args()

    if len(args) == 0:
        print "Needs one or more arguments (files) to compile!"
        sys.exit(1)

    for fileName in args:
        if options.write:
            print "Compiling %s => %s%s" % (fileName, fileName, options.extension)
        else:
            print "Compiling %s => stdout" % fileName

        restree = treegenerator.createSyntaxTree(tokenizer.parseFile(fileName, "", options.encoding))

        if options.optimizeVariables:
            variableoptimizer.search(restree, [], 0, 0, "$")

        if options.compress:
            options.prettyPrint = False  # make sure it's set
        else:
            options.prettyPrint = True
        compiledString = compile(restree, options)
        if options.write:
            if compiledString != "" and not compiledString.endswith("\n"):
                compiledString += "\n"

            filetool.save(fileName + options.extension, compiledString)

        else:
            try:
                print compiledString

            except UnicodeEncodeError:
                print "  * Could not encode result to ascii. Use '-w' instead."
                sys.exit(1)



if __name__ == '__main__':
    try:
        main()

    except KeyboardInterrupt:
        print
        print "  * Keyboard Interrupt"
        sys.exit(1)
